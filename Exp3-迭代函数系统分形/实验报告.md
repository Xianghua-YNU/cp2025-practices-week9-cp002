# 迭代函数系统(IFS)分形实验报告

## 实验目的

1. 理解迭代函数系统(IFS)的基本原理和算法
2. 掌握"混沌游戏"随机迭代方法
3. 实现巴恩斯利蕨和概率树的生成
4. 分析不同参数对分形图形的影响

## 实验过程

### 1. 核心算法实现

**IFS参数定义**:
- 巴恩斯利蕨: 4个仿射变换(茎干、小叶片、左右大叶片)
- 概率树: 3个仿射变换(树干、左右分支)

**混沌游戏算法**:
1. 初始化起始点
2. 随机选择变换(按概率)
3. 应用仿射变换生成新点
4. 重复迭代生成点集

### 2. 分形实现

**巴恩斯利蕨参数**:
- 茎干变换: 概率0.01
- 小叶片变换: 概率0.85
- 左右大叶片变换: 各概率0.07

**概率树参数**:
- 树干变换: 概率0.10
- 左右分支变换: 各概率0.45

### 3. 遇到的问题与解决
初始点选择导致分形不完整:
如果初始点选择不当（如 (0, 0)），可能会导致生成的图形不完整或收敛缓慢。例如，某些变换可能无法覆盖所有分支。
解决：使用合理的初始点（如 (0.5, 0)），确保它能被所有变换覆盖。
跳过前 num_skip 个点（如 100 次迭代），避免初始不稳定状态影响最终图形。

概率分布不均匀导致分形失真：
如果变换的概率分配不合理（如茎干的概率过高），可能导致某些部分（如叶片）点密度不足，图形失真。
解决：调整概率参数，确保关键部分（如叶片）有足够的点覆盖。例如，巴恩斯利蕨的主叶片概率设为 0.85，茎干仅 0.01。
验证概率总和是否为 1（np.random.choice 要求），否则会报错。

## 结果展示

### 1. 巴恩斯利蕨
![3c805c09d6df411f6fc94505d2b42c2d](https://github.com/user-attachments/assets/8f546421-d5a4-450f-934b-bbf1d94de4a8)

- 展示不同变换对应的叶片部分
变换1: 茎干 (p=0.01)效果：生成蕨的垂直茎干。
变换2: 小叶片 (p=0.85)效果：生成主体叶片（蕨的主要部分）。
变换3: 左侧大叶片 (p=0.07)效果：生成左侧较大的叶片分支。
变换4: 右侧大叶片 (p=0.07)效果：生成右侧较大的叶片分支（对称于变换3）。

- 分析概率参数对叶片密度的影响
概率p决定了每个变换被选中的频率，直接影响不同部分的点密度。
茎干	0.01	极低概率，茎干稀疏但关键（若 p=0，茎干消失）。
小叶片	0.85	高概率，确保主体叶片密集且连续（若降低，蕨会显得“破碎”）。
左叶片	0.07	低概率，左侧叶片较稀疏（若增加，左侧会过于浓密，破坏对称性）。
右叶片	0.07	同上，保持左右平衡（若不等，分形会偏向一侧）。

### 2. 概率树 
![20f471d1cf10a32d358aa8f2332082fc](https://github.com/user-attachments/assets/809cafbe-bdd2-43c8-ab82-a51054a81178)

- 展示分支结构
变换1：树干 (p=0.10)效果：生成垂直的树干，高度压缩为原来的50%（d=0.5），无旋转或偏移。
变换2：左分支 (p=0.45)效果：生成向左上方生长的分支，包含旋转（a,b,c,d 参数控制45°旋转）和轻微上移（f=0.2）。
变换3：右分支 (p=0.45)效果：生成向右上方生长的分支（对称于左分支，旋转方向相反）。

- 分析变换参数对树形的影响
(1) 缩放比例（a,d）
a,d>1：分支会放大（树形向外扩展）。
0<a, d<1：分支会收缩（树形向内收敛）。
a≠d：分支在x/y方向不对称缩放（如 a=0.5, d=0.8 会使分支变矮胖）。

(2) 旋转角度（b,c）
b,c≠0：引入旋转或剪切效果。
b=-c：表示纯旋转（如b=0.42,c=-0.42代表45°左旋）。
b=c：表示剪切变形（如b=0.42,c=0.42会使分支倾斜）。

(3) 平移（e,f）
e：控制水平偏移（正值向右，负值向左）。
f：控制垂直偏移（正值向上，负值向下）。

## 分析与思考

1. **IFS特性分析**
   - 仿射变换参数对图形各部分的影响
线性变换部分（a, b, c, d）
参数	数学作用	对图形的影响	示例（巴恩斯利蕨）
a,d	x/y方向的缩放因子	a,d>1：放大；0<a,d<1：收缩	茎干 d=0.16 → 高度压缩为16%
b,c	旋转和剪切控制	b=-c：纯旋转；b=c：剪切	左分支 b=-0.26, c=0.23 → 左旋叶片
a≠d	非均匀缩放	图形拉伸或压扁	若 a=0.5, d=1 → 水平压缩，垂直不变

平移部分（e, f）
参数	作用	对图形的影响	示例（概率树）
e	水平偏移	正值右移，负值左移	右分支 e=0 → 无水平偏移
f	垂直偏移	正值上移，负值下移	所有分支 f=0.2 → 每次变换上移0.2单位

   - 概率参数与图形密度的关系
概率 p 决定了不同变换的应用频率，直接影响图形各部分的点密度：
高概率（p>0.5）	对应部分点密集，形成主体结构	蕨的小叶片 p=0.85 → 覆盖85%的点
低概率（p<0.1）	对应部分稀疏，但可能关键	蕨的茎干 p=0.01 → 仅1%的点，但必不可少
对称概率	保持图形对称性	树的左右分支 p=0.45 →对称生长

2. **参数实验**
   - 修改概率参数的效果
     概率参数p控制不同变换的应用频率，直接影响分形各部分的密度和可见性。
     变换部分	原概率 (p)	调整概率	效果变化
茎干	0.01	→ 0.05	茎干变粗（点数增多），但可能破坏蕨的纤细感
小叶片	0.85	→ 0.70	主体叶片变稀疏，侧叶相对更明显，整体结构更“松散”
左叶片	0.07	→ 0.12	左侧叶片密度增加，若右叶片概率不变，蕨会向左倾斜
右叶片	0.07	→ 0.03	右侧叶片几乎消失，破坏对称性
高概率 (p>0.5)：对应区域点密集，形成主体结构（如蕨的小叶片）。
低概率 (p<0.1)：稀疏但关键（如茎干若 p=0，整个蕨无支撑）。
对称概率：左右分支概率必须相等，否则图形会偏向一侧。

   - 调整变换参数的效果
仿射变换参数 (a, b, c, d, e, f) 控制图形的几何变形，包括旋转、缩放、平移等。
参数	调整目标	示例修改	效果变化
a	水平缩放	a=0.85 → a=0.6	叶片水平收缩，变窄
d	垂直缩放	d=0.85 → d=1.0	叶片垂直拉伸，变高
b	右旋剪切	b=0.04 → b=0.1	叶片向右倾斜
c	左旋剪切	c=-0.04 → c=-0.1	叶片向左倾斜
e	水平平移	e=0.0 → e=0.2	整体右移
f	垂直平移	f=1.6 → f=2.0	叶片间距增大，图形更松散

4. **扩展思考**
   - 如何设计新的IFS规则生成其他分形
      (1)确定分形结构
      目标形状：分析目标分形的自相似结构（如雪花、山脉、树枝等）。
      分解变换：将形状拆解为多个部分，每个部分由一个仿射变换生成。
      (2)设计仿射变换参数
      缩放 (a,d)：控制各部分大小。
      旋转 (b,c)：控制方向（如 b=-c 表示纯旋转）。
      平移 (e,f)：控制位置偏移。
      剪切：通过 b≠-c 实现变形效果。
      (3) 设置概率分布
      主体结构赋予高概率（如 p=0.7），细节部分低概率（如 p=0.05）。

   - 添加颜色渐变效果的方法
   通过映射点的迭代次数或位置到颜色，实现渐变效果。
   基于迭代次数的颜色渐变：
def run_ifs_with_color(ifs_params, num_points=100000):
    probs = [p[-1] for p in ifs_params]
    indices = np.arange(len(ifs_params))
    
    point = (0, 0)
    points = np.zeros((num_points, 2))
    colors = np.zeros(num_points)  # 存储颜色值
    
    for i in range(num_points):
        idx = np.random.choice(indices, p=probs)
        point = apply_transform(point, ifs_params[idx])
        points[i] = point
        colors[i] = i / num_points  # 颜色随迭代次数变化
    
    return points, colors

points, colors = run_ifs_with_color(get_fern_params())
plt.scatter(points[:,0], points[:,1], s=1, c=colors, cmap='viridis', alpha=0.6)

   - 性能优化方案(减少点数同时保持视觉效果)
自适应点密度（非均匀采样）
在分形的不同区域使用不同的点密度，细节丰富的区域保留更多点，简单区域减少点数。
def adaptive_run_ifs(ifs_params, base_points=50000, detail_factor=3, num_skip=100):
    """自适应点密度生成"""
    # 首先生成基础点集用于分析密度
    base_set = run_ifs(ifs_params, base_points, num_skip)
    
    # 使用KDE估计点密度
    from scipy.stats import gaussian_kde
    kde = gaussian_kde(base_set.T)
    densities = kde(base_set.T)
    
    # 按密度比例采样
    prob = densities/densities.sum()
    selected = np.random.choice(len(base_set), size=base_points//detail_factor, p=prob)
    
    return base_set[selected]

6. **算法比较**
   - IFS与其他分形生成方法的对比
     IFS（迭代函数系统）
     优点：代码简单（仅需矩阵运算+随机选择），对自然形态（如植物、云朵）建模能力强（Barnsley蕨、Sierpinski三角形）。
     缺点：参数调优困难（需精确设计变换参数），生成复杂分形需要较多变换规则，难以直接控制局部细节，数学理论完备（满足压缩映射定理必收敛）。

      L-System（林氏系统）：
      优点：对分枝结构（树木、藻类）表现力极强、规则直观易设计（类似语法规则）、支持参数化（如分枝角度、长度）。
      缺点：生成非分枝分形（如Mandelbrot集）困难、递归深度影响性能。
     
   - 随机迭代与确定性迭代的差异
特性	随机迭代	确定性迭代
迭代策略	按概率随机选择变换	对所有变换依次应用
数学描述	马尔可夫链（概率驱动）	确定性映射（固定顺序）
点生成方式	单点轨迹随机游走	批量点并行变换
收敛保证	压缩映射定理 + 概率覆盖	压缩映射定理

关键代码：
随机迭代法：
import numpy as np

def random_iteration(ifs_params, num_points=50000, skip=100):
    """随机迭代生成分形点云"""
    # 提取概率参数
    probs = [p[-1] for p in ifs_params]
    cum_probs = np.cumsum(probs)  # 累计概率用于快速选择
    
    # 初始化
    point = np.zeros(2)
    points = np.zeros((num_points, 2))
    
    for i in range(num_points + skip):
        # 按概率随机选择变换
        r = np.random.random()
        for idx, cp in enumerate(cum_probs):
            if r <= cp:
                a, b, c, d, e, f, _ = ifs_params[idx]
                point = np.array([a*point[0] + b*point[1] + e,
                                 c*point[0] + d*point[1] + f])
                break
        
        # 跳过初始不稳定点
        if i >= skip:
            points[i - skip] = point
    
    return points

    确定性迭代法：
    def deterministic_iteration(ifs_params, init_points, iterations=5):
    """确定性迭代生成分形"""
    points = init_points.copy()  # 初始点集（通常为单个原点）
    
    for _ in range(iterations):
        new_points = []
        for (x, y) in points:
            for a, b, c, d, e, f, _ in ifs_params:  # 应用所有变换
                new_points.append([a*x + b*y + e, c*x + d*y + f])
        points = np.array(new_points)
        
        # 可选：限制点数避免爆炸
        if len(points) > 100000:
            points = points[np.random.choice(len(points), 100000, replace=False)]
    
    return points

**注：请在每一部分补充你自己的实验内容、图像、分析和关键代码。**
